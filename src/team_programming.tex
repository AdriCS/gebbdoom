
\section{Programming}
Migrating from Borland C++ editor on DOS to TextEdit on NeXTSTEP was a trade-off. On one side convenient things such as syntax highlighting were lost. On the other side, apps never crashed. Precious hours of work were never lost. TextEdit also had a developer mode allowing to place markers (\cw{//}) to "fold" code and improve navigation and readability.\\
\par
 The higher resolution (1120 x 832) of the MegaDisplay allowed to see much more code vertically and up to three DOS 80 bytes wide windows side by side. Notice how Borland C++ IDE can only show 21 lines of code while TextEdit could show 57 lines.\\
\par
\fullimage{development.png}\\

\vspace{-4mm}
\cfullimage{TextEditApp.png}{}


In figure \ref{TextEditApp.png}, TextEdit tags and folding show close to 700 lines out of \cw{d\_main.c}'s' 1181 lines. This feature allowed developers to think in terms of systems instead of functions.

\subsection{Interface Builder, OOP and Objective-C}
The list of tool would not be complete without mentioning \NeXT crown jewel which many considered it to be NeXTSTEP killer app, Application Builder.\\
\par
"IB" was first written in Lisp by Jean Marie Hullot in 1984 and commercialized in 1986 under the same "SOS Interface"\footnote{Source: "A Brief History of Human Computer Interaction Technology".}, Hullot was hired by NeXT, Inc. where along with a team he created a similar tool revolving around Objective-C.\\
\par
The NeXTSTEP version he managed to produce would reduce construction cost of GUI by a factor of 5-10\footnote{Source: "NeXT vs Sun: A world of a difference", 1991 promotional video.}.\\
\par
\fullimage{ib.png}



\vspace{-4mm}
 With IB, all the drudge part GUI authoring work was done with a mouse within the blink of an eye. The "tedious" part involving writing code was only mandatory for the actual meat of the application in the business logic layer. Creating the GUI was a two steps process. First draw all elements, then connect the UI elements to the Object models.\\
\par
The first part was, as Steve Jobs qualified it, "insanely easy" since building an interface was done with a series of drag and drop from a palette of GUI elements to a canvas. An inspector allowed to see the properties of an element. Everything from min/max of a slider to the default value of a textfield could be adjusted easily.\\
\par
The second part, connecting the visual elements to the business logic objects, was also done with the mouse by connecting visual boxes to target/actions. The target could be a boolean property in the case of a checkbox UI element or it could be a method in the case of a button UI element.
%\par
%The developer could focus its time on implementing only the business logic.\\

\subsubsection{Object Oriented Programming}
Beyond its revolutionary design, IB was nicely completed by the OOP (Oriented Object Programming) provided by a programmer friendly language called Objective-C.\\
\par
\fq{In my 20 years in this industry, I have never seen a revolution as profound as [object-oriented-programming]. You can build software literally 5 to 10 times faster, and that software is much more reliable, much easier to maintain and much more powerful... All software will be written using this object technology someday. No question about it.}{Steve Job, Rolling Stone, June 16, 1994.}\\
\par
OOP's encapsulation, inheritance and polymorphism allowed to push back the limits of complexity a human programmer could deal with. A program would be conceptualized as a collection of potentially nested sub-systems. The mental image did not have to be a complex monolithic block. It could be decomposed in smaller easier to summarize opaque systems.\\

\par
\subsubsection{Objective-C}
Objective-C was developed around the same time as C++. However as the co-creator Brad Cox recalls, his creation and Bjarne Stroustrup's creation had opposed philosophy. Where C++ placed performance first, Objective-C valued programmer's productivity first.\\
\par
\fq{
	FAB TO ADJUST. Back in 1980 when both our language were under construction, I came down and met with Bjarne Stroustrup. We had radically different view on what our languages would be designed. The key concept was the relative importance of machine efficiency vs programmer efficiency. Eventually, we agreed to disagree.
} {Brad Cox}\\
\par


\par
The version shipping with NeXT computer featured an important library called Foundation Kit. One of its component, \cw{NSObject}, freed developer from the error prone memory management burden by offering reference counting via its \cw{retain} and \cw{release} method. A collection of swiss army knife containers \cw{NSArray}, \cw{NSDictionary}, \cw{NSSet}, \cw{NSData} once again allowed to focus on the core functionality instead of losing time on infrastructure.\\
\par
\trivia{Initially using the prefix NX, all objects in Foundation were rename with a leading NS for OpenSTEP where "NS" stands for the alliance NeXT/Sun\_Microsystems. All these objects are still the core of MacOSX and iOS today, the prefix NS was never removed.}\\
\par
The very core of Obj-C arcbitecture, based on messages routed via a dispatching method \cw{objc\_msgSend} allowed program to be more resilient to errors. By far the most amazing was the ability to send message to null. When a developer sent a message to an object via the following syntax.\\ \par
\objccode{obj.message}
What really happened behind the scene was a call to the dispatch.\\
\par
\objccode{objc_msgSend.m}
The highly optimized, hand written assembly was called millions of time by the time a NeXT had booted. The list of capabilities was impressive\footnote{Source: "Dissecting objc\_msgSend on ARM64" by Mikea Ash.}. Despite the complex mutable nature of ObjC objects (a method can be added at runtime, changing its duck type\footnote{Duck typing uses the principle "If it walks like a duck and it quacks like a duck, then it must be a duck.".}) \cw{objc\_msgSend} was able to march an inheritance chain at runtime to find the proper target. More importantly, it was also able to detect a \cw{nullptr} and simply returning the value \cw{0} instead of bringing the entire process down.\\
\par

All together, the three pillar of NeXT development (AB, OOP, and Obj-C) sped up development of DoomED, doombsp, wadlink and all \NeXT based tools by a factor of two to three.

