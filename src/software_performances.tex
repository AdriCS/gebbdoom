\pagebreak
\section{Performances}
There is a convenient and portable way to assess performances of the engine. Thanks to its fixed tics architecture, a demo can be replayed with frame skipping disabled. This replay mode (called timedemo) will produce the exact same game session and a series of exact same 3D views on any machine.\\
\par
The gold standard of benchmarks was created by Anton Ertl around 1994. Over the last twenty five years, he has gathered metrics for hundreds of configuration\footnote{Source: https://www.complang.tuwien.ac.at/misc/doombench.html}.  It is simple to run and only requires Doom shareware v1.9.\\
\par
\fakedosoutput{timedemo.txt}
\par
These parameters run the prerecorded game session \#3 (probably recorded by John Romero). Because no frames are skipped, the session takes a variable time to finish. Upon completion two values are displayed.\\
\par
\fakedosoutput{timedemo_result.txt}
\par

\cw{gameticks} is the number of frames encountered. For \cw{demo3} it is always equal to 2134 since it comes from the record lump. The second value, \cw{realticks}, represents the walltime in ticks. It represent how fast the machine managed to replay the record.\\
\par
 The average frame per second is obtained with the following formula: $$ fps = walltime/realticks * 35 $$ 
In the example above\footnote{On a miniPC Unisys CWD 4001 (486DX2-66/CirrusLogic-GD5424).}, the game ran at an average of $1065/2134*35 = 17$ fps.\\
\par
Foone Turing was kind enough to volunteer his fleet of machine to assess performances upon release. Varying CPU and graphic cards gave fluctuating results.\\
\par

\begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ L{1}  R{0.3} R{2.4} R{1} R{0.3} }
  \toprule
   \textbf{CPU} & \textbf{Frequency} & \textbf{Graphic card} & \textbf{Bus} & \textbf{fps}\\
  \toprule 
  386DX & 33 & Tseng Labs ET3000    & ISA-8  &  4\\
  386DX\protect\footnotemark & 33 & Cirrus Logic CL-G05420 & ISA-16 &  7\\
  \toprule 
  486SX & 33 & Tseng Labs ET3000                & ISA-8  &  7\\
  486SX & 33 & Cirrus Logic CL-G05420           & ISA-16 & 11\\ 
  486SX & 33 & Diamond Stealth (Tseng ET4000)   & VLB    & 15\\
  \toprule 
  486DX2 & 66 & Tseng Labs ET3000               & ISA-8  &  8\\
  486DX2 & 66 & Cirrus Logic CL-G05420          & ISA-16 & 13\\
  486DX2 & 66 & Diamond Stealth (Tseng ET4000)  & VLB    & 24\\
   \toprule
 \end{tabularx}
\caption{Benchmark with out-of-the-box Doom shareware}
\end{figure}
\footnotetext{For reference, this configuration was able to run Wolfenstein 3D at 20 fps.}
\par
Without tweaking the configuration a top of the line machine could barely reach 25 fps\footnote{It would not be until Pentium with PCI buses came out that \doom could be maxed out at 35 fps}. Notice the importance of the bus, which yields a 3x performance hit/boost. At equal frequency a 486 provides twice the framerate of a 386.\\
\par






\subsection{Profiling}
Even without any special tools, it is possible to gain insight on which part of the engine are responsible for resources consumptions thanks to built-in command line parameters.\\
\par
Parameter \cw{-nodraw} skips rendering all together (but does blit).\\
\par
\par
\fakedosoutput{timedemo_result_nodraw.txt}
\par
Without drawing, the game ran at close to 202fps.\\
\par
Parameter \cw{-noblit} renders to RAM but doesn't transfer the content to VRAM which is a good way to assess the impact of the bus speed. Because of optimization described later this parameter was only available on non-DOS versions.\\
\par
\tcode{timedemo_result_noblit.txt}
\par
An excellent performance visualizer are flamegraphs. They are built by repeatedly interrupting a process, unwinding the stack starting from the Program Counter to generate a backtrace. The process is repeated hundreds of time over the course of the demo. When the demo is done, all backtrace are merged together.\\
\par
 This produces a tree where the width represents 100\% of the time and each level is a function call. It provides a  visual representation of were was the CPU during each part of a frame. On NeXTStep, thank to the multiprocess capability of the OS is easy to use \cw{gdb} from a second terminal and gather backtraces. The result looks as follow.\\
\par

\drawing{flamegraph}{\doom demo1 on NeXT, flamegraph stats}
\par
Without too much surprise, \cw{D\_DoomLoop} acccounts for 100\% of the time, with \cw{D\_Display} overwhelmingly dominating\footnote{But keep in mind NeXTStep port did not implement the audio system.}. Gameplay (\cw{TryRunTics}) (on the very right) is barely visible.\\
\par
On DOS generating a flamegraph is slightly more difficult since it is a mono-threaded operating system. However with a little bit of instrumentation it is possible to get something similar.\\
\par
\drawing{dos_flamegraph}{}
\par
We see that sound doesn't consume much since the only work to do is to retrieve sfx and music data from the wad and place them in the RAM for the audio card to use. Something weird though is that \cw{I\_FinishUpdate} seems instantaneous which leads us to DOS optimizations.\\
\par


\subsection{Optimizations}
For obvious reasons, the DOS version received special care. Two area of bottlnecks were identified in the math function and in the renderer.\\
\par
Since Fixed point operation were performed a lot, \cw{FixedMul} and  \cw{FixedDiv2}. \cw{FixedMul} optimized with inline assembly and unrolled loops\footnote{There is almost no assembly in \doom. Around 1994, John Carmack even declared that "The days of assembly are counted". That was without counting on Intel's Pentium which super-scalar architecture would require extra care by Michael Abrash for Quake.}.\\
\par
\cw{FixedMul} is called 124 times in the source code. Good candidate for optimization. Benchmark disabling it.\\
TODO:Benchmark improvement. Also \fixme{Self-modifying code}\\
\par
A more substantial optimization had to do with the layering. On DOS the rules separating the kernel and the video system were bent slightly. Parts like the status bar and the auto-map still function as originally designed but the drawing routines in the kernel such as \cw{R\_DrawColumn} and \cw{R\_DrawSpanFAB} are given privileged. They are able to access the VGA framebuffer discretely, bypassing framebuffer \#0. Since the menu module has to be able to draw on to of the 3D canvas, it is also granted direct VGA VRAM access.\\
\par
In the code this is achieved with \cw{\#ifdef \_\_WATCOMC\_\_} blocks. It granted a substantial 15\% frame rate improvement.\\
 \par 
TODO: Graph ASM vs NO ASM.\\
 \par
 \fq{An exercise that I try to do every once in a while is to "step a frame" in the game, starting at some major point like common->Frame(), game->Frame(), or renderer->EndFrame(), and step into every function to try and walk the complete code coverage. This usually gets rather depressing long before you get to the end of the frame. Awareness of all the code that is actually executing is important, and it is too easy to have very large blocks of code that you just always skip over while debugging, even though they have performance and stability implications.}{John Carmack}
\par




\section{Performance tuning}
Despite all the care and optimizations, most user could not get more than 10fps at maximum resolution. Two tuning mechanisms helped to reduce the number of pixels to write in order to improve the frame rate.
\begin{enumerate}
\item High detail/Low detail toggle.
\item Adjust size of 3D canvas.
\end{enumerate}
\par





\section{High/Low details}
The first tuning option was to lower horizontal resolution. In low resolution the engine only renders one out of very two columns. This results in a tremendous performance improvement since less pixel value are generated but they also don't have to transit on the bus. Given the 3D renderer domination of the frame rate, performance gains is almost a x2 multiplier.\\
\begin{figure}[H]
\centering  
\begin{tabularx}{0.7\textwidth}{ C{1}  C{1} C{1}}
  \toprule
  \textbf{numblocks} & \textbf{High details fps} &  \textbf{Low details fps}\\
  \toprule 
11 &  19     &        30 \\
10  &  XX      &      XX \\
9  &  XX      &       XX \\
8  &  XX      &       XX \\
7  &  XX      &       XX \\
6  &  XX      &       XX \\
5  &  XX      &       XX \\
4  &  XX      &       XX \\
3  &  45      &       54 \\
  \toprule
\end{tabularx}
\caption{Platform code specific.\protect\footnotemark}
\end{figure}
\footnotetext{Benchmark machine: Unisys CWD 4001 (486DX2-66 Cirrus Logic VLB.}
\fullimage{high_res.png}\\
\par
Above the resolution is 320x200. Below it is dropped to 160x200 with uneven columns duplicated. The resolution drop is particularly noticeable on the non-magnified sergeant and the door but only because diminished lightning and CRT scaling had been disabled for demonstration purposes. In practice the difference was subtle.\\
\par
\fullimage{low_res.png}\\






\section{3D Canvas size adjustment}
An other option to improve the framerate was to lower the size of the 3D canvas. The player had access to a sliding bar allowing to select between eight sizes. The slider was a multiplier affecting \cw{numblocks} to produce a value within range [3,11]\footnote{11 was a special value and hardcoded to be recoginzed as "full-screen" 320x200.}.\\
\par
\ccode{R_ExecuteSetViewSize.c}
\par
\par
\drawing{lod}{The ten 3D canvas configurations.}
\par

\begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ R{1}  R{1} R{1} R{1}  R{1.4}  R{0.6} }
  \toprule
  \textbf{numblocks} & \textbf{Width} & \textbf{Height} & \textbf{\# Pixels} & \textbf{Percentage} & \textbf{fps}\\
  \toprule 

11 & 320 & 200 & 64,000 & 100 & 19 \\
10 & 320 & 168 & 53,760 &  84 & 20 \\
 9 & 288 & 144 & 41,472 &  64 & 23 \\
 8 & 256 & 128 & 32,768 &  52 & 25 \\
 \protect\footnotemark7 & 224 & 112 & 25,088 &  39 & 28 \\
 6 & 192 & 96 & 18,432 &  28 & 31  \\
 5 & 160 & 80 & 12,800 &  20 & 35  \\
 4 & 128 & 64 &  8,192 &  12 & 40  \\
 3 &  96 & 48 &  4,608 &   7 & 45  \\
   \toprule
\end{tabularx}
\caption{Platform code specific.}
\end{figure}

\par

\footnotetext{limit of playability}




\subsection{Developer Mode}
doom -devparm
\trivia{
Doom build time\\ 
Full build = 9:37 (among it: 19s to link)\\
Partial build (r\_sky.c) = 27s (among it 19s to link).\\}
\par

Abstraction layer (compare VGA in wolf3d to doom) incured small overhead but also unlocked new algorithm and allowed easy port -> even a fridge runs doom.\\
\par
NextStep dithering.\\
\\ 

\par
\trivia{To play nicely with cachelines (at least for read operations), texture data are stored as column major (rotated 90 degrees left).}\\




