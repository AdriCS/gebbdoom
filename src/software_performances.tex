\section{Performances}
\fq{An exercise that I try to do every once in a while is to “step a frame” in the game, starting at some major point like common->Frame(), game->Frame(), or renderer->EndFrame(), and step into every function to try and walk the complete code coverage. This usually gets rather depressing long before you get to the end of the frame. Awareness of all the code that is actually executing is important, and it is too easy to have very large blocks of code that you just always skip over while debugging, even though they have performance and stability implications.}{John Carmack}
\par
\trivia{Last minute bug with lock only John Carmack could have figured it out.}
\par


Doom ASM improved performances by 16\%. Detail here the method (timedemo) and realtick. FPS 14 to 16.\\
\par


\subsubsection{Hand Optimized Assembler}
There was very little optimized assembler in \doom compared to previous title. The compiler and \cw{libc} were becoming so good that there was no more need to. Only the drawing routines for the walls and flats were optimized wich resulted in a 15\% performance books. \fixme{Graph ASM vs NO ASM}. John Carmack even declared that "The days of assembly are counted". That was without counting on Intel's Pentium which super-scalar architecture would require extra care by Michael Abrash for Quake.

\trivia{The source code released \cw{linuxdoom-1.10} was considably altered. XX created many more headers files which make the architecture clearer and also increased compilation speed.}


\par

The kernel is made of 45 translation units and is common to all version of \doom.\\
\par

\trivia{What are the dot during startup?}



\par

\trivia{
Doom build time\\ 
Full build = 9:37 (among it: 19s to link)\\
Partial build (r\_sky.c) = 27s (among it 19s to link).\\}
\par

Abstraction layer (compare VGA in wolf3d to doom) incured small overhead but also unlocked new algorithm and allowed easy port -> even a fridge runs doom.\\
\par
NextStep dithering.\\
\\ 

\drawing{flamegraph}{}