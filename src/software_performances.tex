\section{Performances}
There is a convenient and portable way to assess the performance of the game on \doom. Thanks to its fixed tics architecture, a demo can be replayed with frame skipping disabled. This means the machine will render the exact same game and a serie of exact same 3D views.\\
\par
The gold standard of benchmarks was created by XXX around 1994. Ove the last twenty five years, he has gathered metrics for more than hundrers of configuration. The method is simple, run a demo using the Ultimate Doom v1.9.\\
\par
\fakedosoutput{timedemo.txt}
\par
Which returns two values:\\
\par
\fakedosoutput{timedemo_result.txt}
\par

gameticks is always equal to 2134, since this is the number of commands in \cw{DEMO1} and none are skipped. The second varible, \cw{realticks}, represents the walltime. The average frame per second is obtained with $$ fps = walltime/realticks * 35 $$. In the example above, ran on a small miniPC, the game ran at an average of $1065/2134*35 = 17$fps.
\par
Testing various CPU and graphic cards gave fluctuating results.\\
\par
TABLE HERE 386 DX 33   VLB  \\
TABLE HERE 386 DX 33   ISA16\\
TABLE HERE 386 DX 33   VLBISA 8\\
TABLE HERE 486 SX 33   VLB\\
TABLE HERE 486 SX 33   ISA16\\
TABLE HERE 486 SX 33   ISA 8\\
TABLE HERE 486 DX266   VLB\\
TABLE HERE 486 DX266   ISA16\\
TABLE HERE 486 DX266   VISA 8\\
\par 
Analysis of impact. VLB vs ISA. 386 vs 486
\subsection{Profiling}
Without any special tools, it is possible to gain insight on which part of the engine are responsible for ressources consumptions thanks to built-in command line parameters.\\
\par
Parameter \cw{-nodraw} skips rendering all together (including blitting).\\
\par
\par
\fakedosoutput{timedemo_result_nodraw.txt}
\par
Without drawing, the game ran at close to 2000fps!\\
\par
Parameter \cw{-noblit} renders to RAM but doesn't transfer the content to VRAM which is a good way to assess the impact of the bus speed.\\
\par
\fakedosoutput{timedemo_result_noblit.txt}
\par
An excellent performance visualizer are flamegraph. They are obtained by interrupting a process, unwinding the stack starting from the Program Counter to generate a backtrace. The process is repeated hundreds of time over the course of the demo. When the demo is done, all backtrace are merged together. This give a figure where the width represents 100\% of the time and an immediate visual representation of were was the CPU during each part of a frame. On NeXTStep a stackframe is easy to obtain using \cw{gdb} running in an other terminal.\\
\par
The flamegraph on figure XX confirms the rough estimate. \cw{TryRunTics} (on the very right) is barely visible \\
\par
TODO Run same test with demo1\\
TODO Run same test with x2 pixels to see if Update\_16 takes more time to render.\\

\drawing{flamegraph}{\doom demo1 on NeXT, flamegraph stats}
\par
On DOS generating a flamegraph is more difficult since it is a monothreaded process. However with a little bit of instrumentation it is possible to get something similar.\\
\par
DRAWING

\subsection{Hand Optimized Assembler}
Drawing walls and flats had been corretly identified as the \#1 bottleneck. The DOS version had hand crafted XXX routines which improved performances by 15\%. These were the only assembly in doom. The compiler and \cw{libc} were becoming so good that there was no more need to. Only the drawing routines for the walls and flats were optimized wich resulted in a 15\% performance books. John Carmack even declared that "The days of assembly are counted". That was without counting on Intel's Pentium which super-scalar architecture would require extra care by Michael Abrash for Quake.\\
\par
 \fixme{Graph ASM vs NO ASM}.
 \par
 STUDY ASM vs C version. Seems to write 8 pixels at at time, reusing offset, saving store instructions. Trying to stress registers.\\
 \cw{FixedMul} is called 124 times in the source code. Good candidate for optimization. Benchmark disabling it.
 \par

\subsection{Look up tables}
Bla
\section{Reduce window size}
Bla. Usage of dirtybox here.
\section{High/Low details}

\fullimage{high_res.png}\\
\fullimage{low_res.png}\\


\subsection{bla}
\trivia{
Doom build time\\ 
Full build = 9:37 (among it: 19s to link)\\
Partial build (r\_sky.c) = 27s (among it 19s to link).\\}
\par

Abstraction layer (compare VGA in wolf3d to doom) incured small overhead but also unlocked new algorithm and allowed easy port -> even a fridge runs doom.\\
\par
NextStep dithering.\\
\\ 


\fq{An exercise that I try to do every once in a while is to “step a frame” in the game, starting at some major point like common->Frame(), game->Frame(), or renderer->EndFrame(), and step into every function to try and walk the complete code coverage. This usually gets rather depressing long before you get to the end of the frame. Awareness of all the code that is actually executing is important, and it is too easy to have very large blocks of code that you just always skip over while debugging, even though they have performance and stability implications.}{John Carmack}
\par
\trivia{Last minute bug with lock only John Carmack could have figured it out.}




\trivia{The source code released \cw{linuxdoom-1.10} was considably altered. XX created many more headers files which make the architecture clearer and also increased compilation speed.}
\par


Doom ASM improved performances by 16\%. Detail here the method (timedemo) and realtick. FPS 14 to 16.\\
\par


\par

The kernel is made of 45 translation units and is common to all version of \doom.\\
\par

\trivia{What are the dot during startup?}


